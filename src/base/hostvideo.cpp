/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include "hostvideo.h"
#include "emu.h"
#include "emuthread.h"
#include "pathmanager.h"
#include "hostinput.h"
#include "configuration.h"
#include <QPainter>
#include <QKeyEvent>
#include <QDir>
#include <QApplication>

struct QGLRect
{
	QGLRect(const QRectF &r)
		:  left(r.left()), top(r.top()), right(r.right()), bottom(r.bottom()) {}

	QGLRect(GLfloat l, GLfloat t, GLfloat r, GLfloat b)
		: left(l), top(t), right(r), bottom(b) {}

	GLfloat left;
	GLfloat top;
	GLfloat right;
	GLfloat bottom;

	operator QRectF() const {return QRectF(left, top, right-left, bottom-top);}
};

/*!
	\class HostVideo
	HostVideo class displays frames generated by the emulation and buttons
	provided by HostInput.
 */

/*!
	Creates a new object of HostVideo. The given \a thread requests \a emu
	to generate frames, which in turn are passed to HostVideo to render on
	screen. Above the frame buttons are rendered by the given \a hostInput.
 */
HostVideo::HostVideo(HostInput *hostInput,
					 Emu *emu,
					 EmuThread *thread,
					 QWidget *parent) :
	QGLWidget(parent),
	m_hostInput(hostInput),
	m_emu(emu),
	m_thread(thread),
    glPainter(this),
    glThread(this)
{
	setAttribute(Qt::WA_NoSystemBackground);
	setAttribute(Qt::WA_AcceptTouchEvents);
    setAttribute(Qt::WA_PaintOutsidePaintEvent);
	setAttribute(Qt::WA_QuitOnClose, false);
	setAutoFillBackground(false);

	m_fpsVisible = emConf.defaultValue("fpsVisible").toInt();
	m_fpsCount = 0;
	m_fpsCounter = 0;
	m_fpsCounterTime.start();

	m_keepAspectRatio = emConf.defaultValue("keepAspectRatio").toBool();

	QObject::connect(m_emu, SIGNAL(videoSrcRectChanged()), SLOT(updateRects()));
    QObject::connect(this, SIGNAL(videoFrameChanged(QImage)), &glPainter,
                     SLOT(paintFrame(QImage)), Qt::QueuedConnection);
}

HostVideo::~HostVideo()
{
}

static inline void setCoords(GLfloat *coords, const QGLRect &rect)
{
	coords[0] = rect.left;
	coords[1] = rect.top;
	coords[2] = rect.right;
	coords[3] = rect.top;
	coords[4] = rect.right;
	coords[5] = rect.bottom;
	coords[6] = rect.left;
	coords[7] = rect.bottom;
}

/*! \internal */
void HostVideo::paintEvent(QPaintEvent *)
{
    // We do nothing here as we render in a distinct thread.
}

void HostVideo::resizeEvent(QResizeEvent *event)
{
    glPainter.resizeViewport(event->size());
}

/*! Sets if fps should be drawn (\a on=true) or not. */
void HostVideo::setFpsVisible(bool on)
{
	m_fpsVisible = on;
}

void HostVideo::startRendering()
{
    glPainter.moveToThread(&glThread);
    connect(&glThread, SIGNAL(started()), &glPainter, SLOT(start()));
    glThread.start();
}

void HostVideo::stopRendering()
{
    glPainter.stop();
    glThread.wait();
}

void HostVideo::updateFrame(QImage frame) {
    emit videoFrameChanged(frame);
}

/*! \internal */
void HostVideo::updateRects()
{
	// update rects if size of source rect changes
	m_srcRect = m_emu->videoSrcRect();
	Q_ASSERT_X(m_srcRect.width() != 0.0f && m_srcRect.height() != 0.0f, "HostVideo", "Define source rect!");
	qreal ww = rect().width();
	qreal wh = rect().height();
	if (m_keepAspectRatio) {
		// calculate proportionally scaled rect
		qreal scale = qMin(ww/m_srcRect.width(), wh/m_srcRect.height());
		qreal w = m_srcRect.width() * scale;
		qreal h = m_srcRect.height() * scale;
		qreal x = ww/2.0f-w/2.0f;
		qreal y = wh/2.0f-h/2.0f;
		m_dstRect = QRectF(x, y, w, h);
	} else {
		// take screen size
		m_dstRect = QRectF(QPointF(), QSizeF(ww, wh));
	}
	QGLRect dst = m_dstRect;
}

/*!
	Sets if aspect ratio must be kept (\a on = true) or frame
	can be displayed on fullscreen.
*/
void HostVideo::setKeepAspectRatio(bool on)
{
	m_keepAspectRatio = on;
	if (m_srcRect.width() != 0.0f)
		updateRects();
}

/*!
	Converts position from host coordinates to emulation coordinates and
	returns as a point.
 */
QPoint HostVideo::convertCoordHostToEmu(const QPoint &hostPos)
{
	QPoint rel = hostPos - m_dstRect.topLeft().toPoint();
	int x = rel.x()*m_srcRect.width()/m_dstRect.width();
	int y = rel.y()*m_srcRect.height()/m_dstRect.height();
	return QPoint(x, y);
}

